---
title: "Something Interesting Baseball"
author: "Jozi McKiernan, Sean O'Keeffe & Sam Woodman"
output: pdf_document
header-includes:
  - \usepackage{graphicx}
bibliography: report.bib
nocite: |
  @ggplot2, @shiny, @dplyr, @RCurl, @jsonlite, @shinydashboard, @RgoogleMaps, @xml, @tidyr, @mosaic, @stringr, @R
---

[//]: # Introduction Section-------------------------------------------------
# Introduction
Root, root, root for the home team - but what if the home team isn't who it used to be? Major League baseball players are traded every season by teams hunting for an edge. Imagine you could predict when your favorite players were going to change teams. Admit it - if you're a baseball fan, you've been puzzled by the logic of GMs as they barter prospects for big names and flip the roster upside down right before a deadline. 
What factors play a role in who gets traded? Obviously, there are some player-external factors - how the team is doing, managerial tendencies, and the state of the player's contract, to name a few - but what about factors related to the player's performance? Surely those play a role as well. And conveniently, there are a whole heap of statistics collected on the performance of every player in the major leagues. So let's check it out - can we predict whether a player will get traded this season based on their current performance? 

[//]: # Data Collection Section----------------------------------------------
# Data Collection
Unfortunately, the official MLB webpages and related fan pages were not created for data scientists. So step one was scraping the data from a number of pages and wrangling it into a usable format. To keep things reasonable, we decided to limit our search to records from the last six years only (2010-2015, inclusive). 
We found that @stats had all of the information that we were looking for, such as individual statistics and yearly team rosters. Another appealing aspect of @stats was that the urls for the web pages were very consistent; the only differences in the urls were differences in years, team names, and player names. Thus, we could write a script that could scrape all the data that we needed without any actions by us, which was appealing and could allow future users to scrape data for years different than 2010-2015.

## List of all players
Because of the setup of @stats, it made the most sense for us to get a list of all the players that played in the MLB from 2010-2015 and then get all of their statistics for that time period. In order to get this data frame of players, we looped over the years and the team names as shown below. Refer to `get_player_names.R` for the full code.
```{r, message=FALSE, eval=FALSE}
baseball.teams <- c("ARI", "ATL", "BAL", "BOS", "CHC", "CHW", "CIN", "CLE", "COL", "DET", 
                    "FLA", "HOU", "KCR", "LAA", "LAD", "MIL", "MIN", "NYM", "NYY", "OAK", 
                    "PHI", "PIT", "SDP", "SFG", "SEA", "STL", "TBR", "TEX", "TOR", "WSN")
players.hitters <- players.pitchers <- data.frame()
for(year in 2010:2015) {
  # Update team codes when necessary
  if(year == 2012) baseball.teams[11] <- "MIA"
  for(team in baseball.teams) {
    cat("year:", year, "; team:", team, "\n")
    # Get team roster
    url.string <- paste("http://www.baseball-reference.com/teams/", team, "/", year, ".shtml", sep = "")
    web.team <- getURL(url.string)
    parsedDoc.team <- readHTMLTable(web.team, stringsAsFactors=FALSE)
    # Add hitters to players.hitters
    # Add pitchers to players.pitchers
  }
}
```

## Player statistics
Thus, we had a data frame of all the pitchers and hitters in the MLB from 2010-2015. As we can see, getting the data from the website was not the issue because the urls were consistent, and all we wanted was the names of the players. It was a bit more effort and data wrangling to get the statistics for each individual player.
Although the urls were consistent for each player, they only used the first five letters of their last name and the first two letters of their first name. Unfortunately, @stats is a database for retired players, and multiple players both currently playing and retired have the same first five letters of their last name and the first two letters of their first name. We were able to work around this issue by checking if both the full name of the player and the years for which we wanted data were in the output from the getURL call. Although we were unable to get data for all the players because of some strange edge cases, we were able to get statistics for the majority of MLB players.

Once we had the statistics, we still had to wrangle the data. @stats includes minor league stats if a player for instance had a minor league rehab assignment, so we had to make sure that we only kept major league data from 2010-2015. Also, if a player is traded in the middle of a year, they have a stat line for their stats with their first team, a line with their stats from their second team, and a line with their stats for the whole year (they have more lines if they were traded more than once). We decided to only keep the stats from the player's first team because these were the stats that they had when management decided to trade them. See the `get_player_stats.R` file for the data scraping or wrangling code.

## Trades
Now that we had all the predicting attributes, the player statistics, we still needed to know if a player was traded.
All transactions for a given month for a given year could be found through @trades.
However, instances exist of teams changing names, while some entries from @trades include minor league teams, so we also needed a list of all the major league baseball teams and their naming history.
In this section, we will discuss some of the subtleties that made this a difficult process.

To keep our project organized, we split up the data collection into their own files. We run all the data collection here and we will have code bits to describe some of the steps. Refer to the `final_project.R` file and all the other supplemental files.
```{r, message=FALSE, eval=FALSE}
setwd("~/Documents/GitHub/MATH154_FinalProject")
source("final_project.R", local=TRUE, echo=FALSE)
```

### Teams
Although list of team names were acquired manually, there are only 30 teams so it was very manageable.
We also got data on the location of every team.
Although a location is given in the team name, situations like the *Florida Marlins* is not an easy thing to locate on a map.
Thus, these locations were also acquired manually, and the team colors were recorded manually.
Lastly, we also wanted latitude and longitude locations for each team, which we obtained from google maps using a package in R called `Rgooglemaps` from @RgoogleMaps.
For each of the city locations, we look up the lat lon data with an API call to Google Maps.

The data looks like
```{r, eval=FALSE}
head(teams, n = 3)
```

### Trade data
Getting the trade data was a problem that we hadn't seen before.
When we tried to scrape the HTML code for this website as we had done previously in this project and in class, no tables appear.
After a decent bit of research, we discovered that the tables are generated on the client side through Java script, which was why scraping the initial request didn't give us anything. 
However, the data itself had to be sent at some point, so after digging through some of the other files transfered, we found a JSON file that seemed to contain all the data we wanted.
Thus, we queried the URL for this file rather than the website as follows.
```{r, eval=FALSE}
# This website loads the table data using Javascript. We go directly to the 
# JSON file which provides the data.
url <- paste('http://mlb.mlb.com/lookup/json/named.transaction_all.bam?start_date=',
             start_date,
             '&end_date=',
             end_date,
             '&sport_code=%27mlb%27',
             sep='')
json <- getURL(url)
tempData <- as.data.frame(fromJSON(json))
```
Next, we trim down the data so that we only keep the data we're interested in.
```{r, eval=FALSE}
# Filter all the things we don't want. 
tempData <- tempData %>%
  # Only want trades
  filter(transaction_all.queryResults.row.type_cd=='TR') %>% 
  # Only want certain columns
  select(transaction_all.queryResults.row.team, 
         transaction_all.queryResults.row.from_team, 
         transaction_all.queryResults.row.player) %>% 
  # Remove any empty rows
  filter(transaction_all.queryResults.row.player != '') %>% 
  # Add a year attribute
  mutate(Year = year) %>% 
  # Add a key to match with stats data
  mutate(MatchKey = paste(transaction_all.queryResults.row.player, Year)) 
```

We did these steps for all 12 months during 2010 to 2015, which ultimately gave us the following table.
```{r, eval=FALSE}
head(trades, n = 3)
```

[//]: # Classification Section-----------------------------------------------
# Classification
We used logisic regression to predict whether or not a player would get traded or not.
We chose logistic regression because the output is like a probability of being traded and so we could have an idea of how confident we can be of the prediction.

We first create the response variable by cross referencing the trade data with the statistics.
```{r, eval=FALSE}
#-------------------------BATTERS-------------------------

# wrangle/mutate batter data 
players.hitters.stats = mutate(players.hitters.stats, player.year = paste(player, Year))
players.hitters.stats = mutate(players.hitters.stats, 
                               traded = 0 + player.year %in% trades$MatchKey)

# Create factor variable for whether or not a player was traded
players.hitters.stats$traded = as.factor(players.hitters.stats$traded)
players.hitters.stats = na.omit(players.hitters.stats)

# Remove categorical predictors and misleading, repetitive, 
# and/or don't make sense from a baseball standpoint predictors
players.hitters.stats = select(players.hitters.stats, Age, BA, OBP, `R/PA`, `RBI/PA`,
                               `2B/PA`, `3B/PA`, `HR/PA`, `SB/PA`, `SO/PA`, traded)
```
We repeat this same process for the pitching data
```{r, eval=FALSE}
#--------------------------PITCHERS--------------------------

#wrangle and mutate pitcher data
players.pitchers.stats = mutate(players.pitchers.stats, player.year = paste(player, Year))
players.pitchers.stats = mutate(players.pitchers.stats, 
                                traded = 0 + player.year %in% trades$MatchKey)

# Create factor variable for whether or not a player was traded
players.pitchers.stats$traded = as.factor(players.pitchers.stats$traded)
players.pitchers.stats = na.omit(players.pitchers.stats)


# Remove categorical predictors and misleading/don't 
# make sense from a baseball standpoint predictors
players.pitchers.stats = select(players.pitchers.stats, Age, `W-L%`, ERA, FIP, WHIP, H9, 
                                HR9, BB9, SO9, traded, `SHO/G`, `SV/G`)
```

Then we can build the classifier on this data. 
In R we can use the function `glm` and specify the family to binomial to do logistic regression.

```{r, eval=FALSE}
#logistic regression for batters
glm.fit.bat = glm(traded~., data = players.hitters.stats, family=binomial)

#logistic regression for pitchers
glm.fit.pitch = glm(traded~., data = players.pitchers.stats, family=binomial)
```

Once we have these fits, we need to come up with a cutoff for which data points are considered a 1 and which ones are 0s.
To do this, we used 10-fold cross validation!
```{r, eval=FALSE}
# Cross validation function
crossValid <- function(d) {
  d = sample(d)
  k = 10
  step = floor(nrow(d)/10)-1
  cutoff_errors = c()
  
  for (c in (1:100)/100) {
    errors = c()
    s_index = 1
    e_index = s_index + step
    for (i in 1:k) {
      temp_train = d[-c(s_index:e_index),]
      temp_test = d[s_index:e_index,]
      temp_fit = glm(traded~., data = temp_train, family = binomial)
      temp_pred = predict(temp_fit, newdata = temp_test, type = "response")
      temp_table = table(temp_pred > c, temp_test$traded)
      if (nrow(temp_table) == 1) {
        if ((temp_pred > c)[1]) {
          errors = c(errors, temp_table[1,1]/nrow(temp_test))
        } else {
          errors = c(errors, temp_table[1,2]/nrow(temp_test))
        }
      } else {
        errors = c(errors, (temp_table[1,2]+temp_table[2,1])/nrow(temp_test))
      }
      s_index = e_index + 1
      e_index = s_index + step
    }
    cutoff_errors = c(cutoff_errors, mean(errors))
  }
  
  return(which(cutoff_errors == min(cutoff_errors))/100)
}
```
Keeping track of the average error for various cutoffs, we found that around 0.4 gave us the best results for hitters.
```{r, eval=FALSE}
crossValid(players.hitters.stats)
```
The pitchers however, gave us interesting results.
The cutoff that gives us the lowest average error is anything at or above 0.92.
```{r, eval=FALSE}
crossValid(players.pitchers.stats)
```
This cutoff actually resultd in a prediction of 0 every single time, this effectively tells us that these variables don't tell us much but how likely it is for a pitcher to be traded.
However, so that we can have a more interesting predictor, we'll use the next best cutoff.
```{r, eval=FALSE}
x = cutoff_errors[1:91]
which(x == min(x))/100
```
We find that this is also around 0.4.

Now that we have a model, we can look into what variables seem to contribute more to determining wether or not a player gets traded.
```{r,eval=FALSE}
glm.fit.bat

glm.fit.pitch
```
For the batters it seems like Triples per plate appearance had the largest coefficient in the regression, followed by batting average.
For pitchers the most influential was WHIP, followed by hits per 9 innings.

[//]: # Shiny Web App Section------------------------------------------------
# Shiny Web App
The Shiny Web App has 3 tabs, Predict Trades, Trades Map, and a Single Variable Trend.
Each one of these tabs will be described below.

## Predict Trades
We built a classifier using statistics of the baseball players to try and predict wether or not a player would get traded.
In this tab you can input statistics on any hitter or batter.
Then the app will magically run that point through our classifier and predict wether or not that player would get traded given those statistics.

## Trades Map

This graphic lets you visualize the trades.
As you can see in Figure~\ref{fig:trades_map}, you can select any number of teams you want and on the map will be all the trades that happened during 2010 to 2015 to that team.

Below that is a data dump of those trades.
This doesn't tell us anything particularly useful about the data, it was just a fun visualization.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{trades_map.png}
\label{fig:trades_map}
\caption{Screenshot of Trades Map tab.}
\end{figure}

## Single Variable Trend
This tab allows you to select one of the predictor variables for batters or pitchers and see it's effects on a player getting traded.
The output is a plot that shows for which values of the selected variable, the players in our data got traded.
Using this, you can get a better understanding of which variables might be important and which ones are irrelevant.
If there was a strong connection between any single variable and a players likelihood to be traded, it would be present in these graphs.

\newpage
